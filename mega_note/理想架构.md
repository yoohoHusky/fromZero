##### 谈及MVC、MVP
> Model， 	众所周知就是控制数据的部分。数据是缓存，还是从网络读都交由该部分处理完，直接向外暴露获取数据的接口。
> View，		则是负责界面效果的部分。不涉及业务，所以控件及触发的方法的命名尽量面向UI本身，而不是面向业务。
> C/P,		C/P的作用则是连接M与V。不同的是
> - C是认为，每一个变化都应该是一个方法，统一在C里做控制，其他的都没有自主权利
> - P是认为，P只做一个中间分发层，把事件做业务处理，数据做适配封装，绕后V自己去处理界面相关的事情，M自己去处理数据相关的事情，P只管调用分发
> - VM是对P的部分简化，本质思想是和P一致的，只是将 V与P 之间的双向通信过程交由dataBinding来自动触发。

1. MVP被设计的
	1. 第一出发点是：希望view、model解耦，代码层次清晰。
 	2. 第二出发点是：希望模块复用，即如果项目 数据不变，只是改变了界面，那么model将可以继续使用，model里的接口也不用修改。我们只要更改view，已经view的接口并在P里做适配，使得V与M依然可以和谐的通信


##### 对M、V、P的构想
1. V层写界面的逻辑，并声明两个接口CView（change view——改变view），ViewC（view changed——view改变了）
2. M层写数据的逻辑，并声明两个接口CModel（change Model），ModelC（Model changed）
3. V实现ViewC，M实现ModelC，VM实现CView和CModel
> （其对应关系有可能是这个样子的：ViewC.btn1Click（这一步dataBinding可以实现） <--> CModel.updateUserInfo）
> (ModelC.userInfoChanged <--> CModel.updateText1(这一步dataBinding可以实现))







